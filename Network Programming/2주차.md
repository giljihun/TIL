# Chapter1. Basic Network Concepts



~~~ 
- Network Programming은 더이상 특정 전문가의 영역이 아니다.
- 모든 개발자들에게 중요한 부분이 되었다.
- Java는 네트워크 어플리케이션을 위해 기초부터 설계된 첫번째 언어이다. (자바로 하는게 쉽다고함)
~~~





> FTP servers :  파일 수신, 전송, 삭제, 디렉토리 생성 또는 제거 등과 같이 원격 클라이언트가 제공한 명령을 실행할 수 있는 하나 이상의 프로그램으로 구성된 컴퓨터 소프트웨어



## Networks

~~~
- 네트워크는 거의 실시간으로 데이터를 주고 받을 수 있는 컴퓨터와 다른 장치들의 집합이다.
- 각각 장치들의 네트워크는 'node(노드)'라고 불린다. (컴퓨터일 수도 있고, 컴퓨터가 아닐 수도 있다.)
- 노드들 중에 완전 컴퓨터같은 노드들은 'hosts(호스트)'라고 불린다. (General - purpose computer)
- 모든 네트워크 노드는 'address(주소)'를 가진다. (주소는 노드들을 특정시킨다.) 
- 모든 현대 컴퓨터 네트워크는 패킷-스위치 네트워크이다.
- 프로토콜은 컴퓨터들이 통신을 하기위한 정밀한 형식이나 규칙이다.
~~~



> IPv4 : 32bits (현재 보편적으로 사용)  2의 32승, 대략 40억 가량의 컴퓨터를 구분이 가능하다는 의미도 된다.
>
> ++ 근데 40억개면 전세계 컴퓨터를 다 처리할 수 있나??? -> 안됨! 이미 IPv4의 신규할당은 끝났다.
>
> ​	그래서 현재 '공유기'가 보편적으로 잘 쓰이고 있다.
>
> IPv6 : 128bits 



> DHCP(동적 호스트 구성 프로토콜) : 자동으로 IP (인터넷 프로토콜)를 호스트 하는 IP 주소 및 서브넷 마스크 및 기본 게이트웨이 등의 기타 관련된 구성 정보를 제공 하는 클라이언트/서버 프로토콜



> Router : 데이터 패킷을 전송하는 네트워크 장치
>
> Routing : 라우팅은 어떤 네트워크 안에서 통신 데이터를 보낼 때 최적의 경로를 선택하는 과정(어디로 가는게 빠를지)



> 패킷 교환 (Packet switching) : 작은 블록의 패킷으로 데이터를 전송하며 데이터를 전송하는 동안만 네트워크 자원을 사용하도록 하는 방법

> HTTP(Hypertext Transfer Protocol) : 웹 페이지를 다른 페이지로 연결하는 링크



## The layers of a Network



**각 계층 are called by**


~~~ 
5: Application

4: Transport 
(TCP, 패킷에 헤더(번호)를 붙이는 역할 -> 유실된 패킷이나 순서의 오류를 해결, 신뢰성good, header byte - 20byte)
(UDP, 패킷을 그냥 던지고 끝 뭐 재전송하거나 맞추거나 하는 기능 X, header byte - 8byte)
(요새 트렌드, UDP로 빠르게 통신하고 Application 계층의 프로토콜에서 불완전한 부분을 처리)
(여기 프로토콜들을 'end-to-end'라고 부른다)

* TCP의 헤더가 붙는 방식
#1, #101, #1101 ...

3: internet or network (IP, 라우팅을 위한 프로토콜, 패킷이 목적지까지 잘 찾아가게 만드는 역할)

2: Data Link (서로 데이터가 충돌이 안나게 데이터를 전송하는 역할)

1: Physical layer
~~~



<img src="/Users/kiljihun/Library/Application Support/typora-user-images/스크린샷 2023-09-08 15.51.13.png" alt="스크린샷 2023-09-08 15.51.13" style="zoom:75%;" />



### TCP

* Connection-Oriental : 연결 지향
* 3 - way handshake : 데이터를 주고 받는데, 3번 과정이 필요 (왜 필요한가?)
  1. initial sequence number를 설정한다 (시작 포인트를 맞춘다.)
  2. OK?
  3. OK! 

-> UDP는 이런거 없다.(but, 매우 빨라.)

-  대부분 패킷이 45로 시작한다.(IPv4에서 Header Length가 5 이므로)

  4(IPv4)와 5가 합쳐져서 45이다.

### Port Number 

* 어플리케이션을 구분하는 용도가 포트번호이다.
* IP에서 TCP로 올린 입장에서, TCP는 이 패킷이 어느 어플리케이션으로 가야할 지를 결정해야한다..
* 그것을 결정하는 것이 Port Number이다.
* 유명한 프로토콜은 모두 고유한 퐅넘.이 있다.
* 나머지들은 임의로 랜덤하게 할당을 해준다.(컴퓨터가 안쓰는 거로 해줘.)



### IP Header

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/IPv4_Packet-en.svg/1200px-IPv4_Packet-en.svg.png" alt="IPv4 - 위키백과, 우리 모두의 백과사전" style="zoom:50%;" />

## 과제
~~~ 
1. IP 패킷 하나를 캡쳐해서 IP Header의 필드 값의 의미와 대응하는 값을 확인하시오. 
~~~

![Alt text](image.png)
(+ 황교수님 맥스튜디오 캡쳐했다.)

> - IP 헤더의 첫 번째 바이트 ‘45’  
-> ‘4’ : IP 버전 (4 -> IPv4)  
-> ‘5’ : IP 헤더 길이  
-> 이 값은 4비트로 표현되며, 헤더의 길이를 32비트 단위로 나타낸다.  
-> 5 X 32(비트) / 8(비트)  = 20바이트  
> - IP 헤더의 나머지 부분에는 출발지 IP 주소, 목적지 IP 주소, TTL (Time To Live), 프로토콜, 헤더 체크섬 및 기타 중요한 정보가 포함된다. 


~~~
2. 내 컴퓨터에서 보내는 IP 패킷들을 순서 대로 여러 개 캡쳐하고 Identification 필드의 값은 어떻게 변하는지 확인하시오.
~~~

![Alt text](image-1.png)

> "Identification" 필드는 패킷의 일련 번호를 나타내며, 패킷이 생성될 때마다 다른 값을 가질 수 있습니다.  
> 패킷 생성기나 송신 소프트웨어에서 이 값을 설정하지 않는 한, 이 필드는 시스템이나 하드웨어에서 자동으로 증가되거나 무작위로 설정됩니다.

~~~
3. 내 컴퓨터가 보내는 IP 패킷들의 TTL 값은 고정인가? 
~~~

![Alt text](image-2.png)

-> 동일했다!

> - TTL (Time To Live) 값은 패킷이 네트워크를 통과할 때 감소하는 값입니다. 제가 이전 답변에서 언급한 것처럼, TTL 값은 패킷이 라우터를 통과할 때마다 1씩 감소하게 됩니다. 이것이 TTL의 주요 기능 중 하나로, 패킷이 네트워크를 이동하면서 TTL 값이 줄어들다가 0이 되면 패킷이 폐기되는 것을 방지합니다.

> - TTL 값이 255로 설정된 패킷이 목적지에 도달하면, 해당 패킷이 255개의 라우터를 통과할 수 있다는 것을 의미합니다. 각 라우터를 지날 때마다 TTL 값이 1씩 감소하므로, 패킷이 최종 목적지에 도달하기 위해서는 255번의 라우터 통과를 허용하는 것입니다.

~~~
4. 내 컴퓨터가 수신한 IP 패킷의 TTL 값은 얼마인가? 보낸 상대방 IP 주소가 다를때 TTL 값을 3개 이상 확인하시오. 
~~~

![Alt text](image-3.png)

~~~
5. IP 패킷의 Header Checksum을 구하는 방법 조사하고, IP 패킷을 하나 캡쳐해서 Header Checksum값이 실제 패킷에서 계산한 것과 같은지 확인하시오. 
~~~
> Hedaer Checksum은 IP 헤더의 오류 검출을 위해 사용된다.

1. IP 헤더 추출.
2. Header Checksum 필드를 제외한 Checksum을 계산.
3. Checksum 계산순서  
(1) IP 헤더를 16비트 단위로 나눈다.  
(IP 헤더는 여러필드로 구성되어 있고, 각 필드는 16비트 크기를 가진다.)  
(2) 나눈 16비트 덩어리를 2진수로 변환, 다 SUM한다.  
(3) 더한 결과 값이 16비트 범위를 벗어나면, 오버플로우된 부분을 다시 더해준다.  
(오버플로우된 비트를 추가하여 계산한다.)  
(4) 최종적으로 얻은 값을 16비트로 나타내고, 1의 보수를 취한다.  
=> Checksum 값이 된다.
